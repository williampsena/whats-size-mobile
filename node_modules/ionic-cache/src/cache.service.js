"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require('@angular/core');
var storage_1 = require('./storage');
var Rx_1 = require('rxjs/Rx');
var http_1 = require('@angular/http');
var MESSAGES = {
    0: 'Cache initialization error: ',
    1: 'Cache is not enabled.',
    2: 'Cache entry already expired: ',
    3: 'No such key: ',
    4: 'No enteries were deleted, because browser is offline.'
};
var CacheService = (function () {
    function CacheService() {
        this.ttl = 60 * 60; // one hour
        this.tableName = 'cache';
        this.cacheKeys = ['key unique', 'value', 'expire INTEGER', 'type', 'groupKey'];
        this.enableCache = true;
        this.invalidateOffline = false;
        this.networkStatus = true;
        try {
            this.storage = new storage_1.SqlStorage();
            this.watchNetworkInit();
            this.initDatabase();
            this.enableCache = true;
        }
        catch (e) {
            this.enableCache = false;
            console.error(MESSAGES[0], e);
        }
    }
    /**
     * @description Disable or enable cache
     */
    CacheService.prototype.disableCache = function (status) {
        if (status === void 0) { status = true; }
        this.enableCache = !status;
    };
    /**
     * @description Create DB table for cache, if not exists
     * @return {Promise<any>}
     */
    CacheService.prototype.initDatabase = function () {
        var query = "CREATE TABLE IF NOT EXISTS " + this.tableName + " (" + this.cacheKeys.join(', ') + ")";
        return this.storage.query(query);
    };
    /**
     * @description Delete DB table and create new one
     * @return {Promise<any>}
     */
    CacheService.prototype.resetDatabase = function () {
        var _this = this;
        return this.storage.query("DROP TABLE " + this.tableName).then(function () {
            return _this.initDatabase();
        });
    };
    /**
     * @description Set default TTL
     * @param {number} ttl - TTL in seconds
     */
    CacheService.prototype.setDefaultTTL = function (ttl) {
        return this.ttl = ttl;
    };
    /**
     * @description Set if expired cache should be invalidated if device is offline
     * @param {boolean} offlineInvalidate
     */
    CacheService.prototype.setOfflineInvalidate = function (offlineInvalidate) {
        this.invalidateOffline = !offlineInvalidate;
    };
    /**
     * @description Start watching if devices is online or offline
     */
    CacheService.prototype.watchNetworkInit = function () {
        var _this = this;
        this.networkStatus = navigator.onLine;
        var connect = Rx_1.Observable.fromEvent(window, 'online').map(function () { return true; });
        var disconnect = Rx_1.Observable.fromEvent(window, 'offline').map(function () { return false; });
        this.networkStatusChanges = Rx_1.Observable.merge(connect, disconnect).share();
        this.networkStatusChanges.subscribe(function (status) {
            _this.networkStatus = status;
        });
    };
    /**
     * @description Stream of network status changes
     * * @return {Observable<boolean>} network status stream
     */
    CacheService.prototype.getNetworkStatusChanges = function () {
        return this.networkStatusChanges;
    };
    /**
     * @description Check if devices is online
     * @return {boolean} network status
     */
    CacheService.prototype.isOnline = function () {
        return this.networkStatus;
    };
    /**
     * @description Save item to cache
     * @param {string} key - Unique key
     * @param {any} data - Data to store
     * @param {string} [groupKey] - group key
     * @param {number} [ttl] - TTL in seconds
     * @return {Promise<any>} - saved data
     */
    CacheService.prototype.saveItem = function (key, data, groupKey, ttl) {
        if (groupKey === void 0) { groupKey = 'none'; }
        if (ttl === void 0) { ttl = this.ttl; }
        if (!this.enableCache) {
            return Promise.reject(MESSAGES[1]);
        }
        var expire = new Date().getTime() + (ttl * 1000);
        var type = CacheService.isRequest(data) ? 'request' : typeof data;
        var value = JSON.stringify(data);
        var valuesMap = { key: key, value: value, expire: expire, type: type, groupKey: groupKey };
        var values = Object.keys(valuesMap).map(function (key) { return ("'" + valuesMap[key] + "'"); });
        var query = "INSERT OR REPLACE INTO " + this.tableName + " (" + Object.keys(valuesMap).join(', ') + ") VALUES (" + values.join(', ') + ")";
        return this.storage.query(query).then(function () { return data; });
    };
    /**
     * @description Delete item from cache
     * @param {string} key - Unique key
     * @return {Promise<any>} - query execution promise
     */
    CacheService.prototype.removeItem = function (key) {
        if (!this.enableCache) {
            return Promise.reject(MESSAGES[1]);
        }
        return this.storage.query("DELETE FROM " + this.tableName + " WHERE key = '" + key + "'");
    };
    /**
     * @description Get item from cache without expire check etc.
     * @param {string} key - Unique key
     * @return {Promise<any>} - data from cache
     */
    CacheService.prototype.getRawItem = function (key) {
        if (!this.enableCache) {
            return Promise.reject(MESSAGES[1]);
        }
        var query = "SELECT * FROM " + this.tableName + " WHERE key = '" + key + "'";
        return this.storage.query(query).then(function (data) {
            if (data.rows.length === 0 || !data.rows.item(0)) {
                return Promise.reject(MESSAGES[3] + key);
            }
            return data.rows.item(0);
        });
    };
    /**
     * @description Get item from cache with expire check and correct type assign
     * @param {string} key - Unique key
     * @return {Promise<any>} - data from cache
     */
    CacheService.prototype.getItem = function (key) {
        var _this = this;
        if (!this.enableCache) {
            return Promise.reject(MESSAGES[1]);
        }
        return this.getRawItem(key).then(function (data) {
            if (data.expire < new Date().getTime()) {
                if (_this.invalidateOffline) {
                    return Promise.reject(MESSAGES[2] + key);
                }
                else if (_this.isOnline()) {
                    return Promise.reject(MESSAGES[2] + key);
                }
            }
            return CacheService.decodeRawData(data);
        });
    };
    /**
    * @description Decode raw data from DB
    * @param {any} data - Data
    * @return {any} - decoded data
    */
    CacheService.decodeRawData = function (data) {
        var dataJson = JSON.parse(data.value);
        if (CacheService.isRequest(dataJson)) {
            var requestOptions = new http_1.ResponseOptions({
                body: dataJson._body,
                status: dataJson.status,
                headers: dataJson.headers,
                statusText: dataJson.statusText,
                type: dataJson.type,
                url: dataJson.url
            });
            return new http_1.Response(requestOptions);
        }
        else {
            return dataJson;
        }
    };
    /**
     * @description Load item from cache if it's in cache or load from origin observable
     * @param {string} key - Unique key
     * @param {any} observable - Observable with data
     * @param {string} [groupKey] - group key
     * @param {number} [ttl] - TTL in seconds
     * @return {Observable<any>} - data from cache or origin observable
     */
    CacheService.prototype.loadFromObservable = function (key, observable, groupKey, ttl) {
        var _this = this;
        if (!this.enableCache)
            return observable;
        observable = observable.share();
        return Rx_1.Observable.fromPromise(this.getItem(key)).catch(function (e) {
            observable.subscribe(function (res) { return _this.saveItem(key, res, groupKey, ttl); });
            return observable;
        });
    };
    /**
     * @description Load item from cache if it's in cache or load from origin observable
     * @param {string} key - Unique key
     * @param {any} observable - Observable with data
     * @param {string} [groupKey] - group key
     * @param {number} [ttl] - TTL in seconds
     * @return {Observable<any>} - data from cache or origin observable
     */
    CacheService.prototype.loadFromDelayedObservable = function (key, observable, groupKey, ttl, delayType) {
        var _this = this;
        if (ttl === void 0) { ttl = this.ttl; }
        if (delayType === void 0) { delayType = 'expired'; }
        if (!this.enableCache)
            return observable;
        var observableSubject = new Rx_1.Subject();
        observable = observable.share();
        var subscribeOrigin = function () {
            observable.subscribe(function (res) {
                _this.saveItem(key, res, groupKey, ttl);
                observableSubject.next(res);
            }, null, function () {
                observableSubject.complete();
            });
        };
        this.getItem(key).then(function (data) {
            observableSubject.next(data);
            if (delayType === 'all') {
                subscribeOrigin();
            }
        }, function (e) {
            _this.getRawItem(key).then(function (res) {
                observableSubject.next(CacheService.decodeRawData(res));
            }).then(function () {
                subscribeOrigin();
            }).catch(function () { return subscribeOrigin(); });
        });
        return observableSubject.asObservable();
    };
    /**
     * Perform complete cache clear
     * @return {Promise<any>}
     */
    CacheService.prototype.clearAll = function () {
        if (!this.enableCache) {
            return Promise.reject(MESSAGES[2]);
        }
        return this.resetDatabase();
    };
    /**
     * @description Remove all expired items from cache
     * @param {boolean} ignoreOnlineStatus -
     * @return {Promise<any>} - query promise
     */
    CacheService.prototype.clearExpired = function (ignoreOnlineStatus) {
        if (ignoreOnlineStatus === void 0) { ignoreOnlineStatus = false; }
        if (!this.enableCache) {
            return Promise.reject(MESSAGES[2]);
        }
        if (!this.isOnline() && !ignoreOnlineStatus) {
            return Promise.reject(MESSAGES[4]);
        }
        var datetime = new Date().getTime();
        return this.storage.query("DELETE FROM " + this.tableName + " WHERE expire < " + datetime);
    };
    /**
     * @description Remove all item with specified group
     * @param {string} groupKey - group key
     * @return {Promise<any>} - query promise
     */
    CacheService.prototype.clearGroup = function (groupKey) {
        if (!this.enableCache) {
            return Promise.reject(MESSAGES[2]);
        }
        return this.storage.query("DELETE FROM " + this.tableName + " WHERE groupKey = '" + groupKey + "'");
    };
    /**
     * @description Check if it's an request
     * @param {any} data - Variable to test
     * @return {boolean} - data from cache
     */
    CacheService.isRequest = function (data) {
        if (data instanceof http_1.Request || (typeof data === 'object' && data.hasOwnProperty('_body') && data.hasOwnProperty('status') &&
            data.hasOwnProperty('statusText') && data.hasOwnProperty('type') && data.hasOwnProperty('headers')
            && data.hasOwnProperty('url'))) {
            return true;
        }
        else {
            return false;
        }
    };
    CacheService = __decorate([
        core_1.Injectable(), 
        __metadata('design:paramtypes', [])
    ], CacheService);
    return CacheService;
}());
exports.CacheService = CacheService;
//# sourceMappingURL=cache.service.js.map