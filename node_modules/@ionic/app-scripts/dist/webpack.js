"use strict";
var logger_1 = require('./util/logger');
var helpers_1 = require('./util/helpers');
var events_1 = require('./util/events');
var config_1 = require('./util/config');
var path_1 = require('path');
var webpackApi = require('webpack');
var fs_extra_1 = require('fs-extra');
var events_2 = require('events');
var eventEmitter = new events_2.EventEmitter();
var INCREMENTAL_BUILD_FAILED = 'incremental_build_failed';
var INCREMENTAL_BUILD_SUCCESS = 'incremental_build_success';
/*
 * Due to how webpack watch works, sometimes we start an update event
 * but it doesn't affect the bundle at all, for example adding a new typescript file
 * not imported anywhere or adding an html file not used anywhere.
 * In this case, we'll be left hanging and have screwed up logging when the bundle is modified
 * because multiple promises will resolve at the same time (we queue up promises waiting for an event to occur)
 * To mitigate this, store pending "webpack watch"/bundle update promises in this array and only resolve the
 * the most recent one. reject all others at that time with an IgnorableError.
 */
var pendingPromises = [];
function webpack(context, configFile) {
    context = config_1.generateContext(context);
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    var logger = new logger_1.Logger('webpack');
    return webpackWorker(context, configFile)
        .then(function () {
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.webpack = webpack;
function webpackUpdate(event, path, context, configFile) {
    var logger = new logger_1.Logger('webpack update');
    var extension = path_1.extname(path);
    var webpackConfig = getWebpackConfig(context, configFile);
    return Promise.resolve().then(function () {
        if (extension === '.ts') {
            logger_1.Logger.debug('webpackUpdate: Typescript File Changed');
            return typescriptFileChanged(path, context.tsFiles);
        }
        else {
            logger_1.Logger.debug('webpackUpdate: Non-Typescript File Changed');
            return otherFileChanged(path).then(function (file) {
                return [file];
            });
        }
    }).then(function (files) {
        // transform the paths
        logger_1.Logger.debug('webpackUpdate: Transforming paths');
        var transformedPathFiles = files.map(function (file) {
            file.path = transformPath(file.path, context);
            return file;
        });
        logger_1.Logger.debug('webpackUpdate: Writing Files to tmp');
        return writeFilesToDisk(transformedPathFiles);
    }).then(function () {
        logger_1.Logger.debug('webpackUpdate: Starting Incremental Build');
        return runWebpackIncrementalBuild(false, context, webpackConfig);
    }).then(function (stats) {
        // the webpack incremental build finished, so reset the list of pending promises
        pendingPromises = [];
        logger_1.Logger.debug('webpackUpdate: Incremental Build Done, processing Data');
        return webpackBuildComplete(stats, context, webpackConfig);
    }).then(function () {
        return logger.finish();
    }).catch(function (err) {
        if (err instanceof logger_1.IgnorableError) {
            throw err;
        }
        throw logger.fail(err);
    });
}
exports.webpackUpdate = webpackUpdate;
function webpackWorker(context, configFile) {
    var webpackConfig = getWebpackConfig(context, configFile);
    // in order to use watch mode, we need to write the
    // transpiled files to disk, so go ahead and do that
    var files = typescriptFilesChanged(context.tsFiles);
    // transform the paths
    var transformedPathFiles = files.map(function (file) {
        file.path = transformPath(file.path, context);
        return file;
    });
    return writeFilesToDisk(transformedPathFiles)
        .then(function () {
        logger_1.Logger.debug('Wrote .js files to disk');
        if (context.isWatch) {
            return runWebpackIncrementalBuild(!context.webpackWatch, context, webpackConfig);
        }
        else {
            return runWebpackFullBuild(webpackConfig);
        }
    }).then(function (stats) {
        return webpackBuildComplete(stats, context, webpackConfig);
    });
}
exports.webpackWorker = webpackWorker;
function webpackBuildComplete(stats, context, webpackConfig) {
    // set the module files used in this bundle
    // this reference can be used elsewhere in the build (sass)
    var files = stats.compilation.modules.map(function (webpackObj) {
        if (webpackObj.resource) {
            return webpackObj.resource;
        }
        else {
            return webpackObj.context;
        }
    }).filter(function (path) {
        // just make sure the path is not null
        return path && path.length > 0;
    });
    context.moduleFiles = files;
    // async cache all the module paths so we don't need
    // to always bundle to know which modules are used
    helpers_1.setModulePathsCache(context.moduleFiles);
    events_1.emit(events_1.EventType.FileChange, getOutputDest(context, webpackConfig));
    return Promise.resolve();
}
function runWebpackFullBuild(config) {
    return new Promise(function (resolve, reject) {
        var callback = function (err, stats) {
            if (err) {
                reject(new logger_1.BuildError(err));
            }
            else {
                resolve(stats);
            }
        };
        var compiler = webpackApi(config);
        compiler.run(callback);
    });
}
function runWebpackIncrementalBuild(initializeWatch, context, config) {
    var promise = new Promise(function (resolve, reject) {
        // start listening for events, remove listeners once an event is received
        eventEmitter.on(INCREMENTAL_BUILD_FAILED, function (err) {
            logger_1.Logger.debug('Webpack Bundle Update Failed');
            eventEmitter.removeAllListeners();
            handleWebpackBuildFailure(resolve, reject, err, promise, pendingPromises);
        });
        eventEmitter.on(INCREMENTAL_BUILD_SUCCESS, function (stats) {
            logger_1.Logger.debug('Webpack Bundle Updated');
            eventEmitter.removeAllListeners();
            handleWebpackBuildSuccess(resolve, reject, stats, promise, pendingPromises);
        });
        if (initializeWatch) {
            startWebpackWatch(context, config);
        }
    });
    pendingPromises.push(promise);
    return promise;
}
function handleWebpackBuildFailure(resolve, reject, error, promise, pendingPromises) {
    // check if the promise if the last promise in the list of pending promises
    if (pendingPromises.length > 0 && pendingPromises[pendingPromises.length - 1] === promise) {
        // reject this one with a build error
        reject(new logger_1.BuildError(error));
        return;
    }
    // for all others, reject with an ignorable error
    reject(new logger_1.IgnorableError());
}
function handleWebpackBuildSuccess(resolve, reject, stats, promise, pendingPromises) {
    // check if the promise if the last promise in the list of pending promises
    if (pendingPromises.length > 0 && pendingPromises[pendingPromises.length - 1] === promise) {
        logger_1.Logger.debug('handleWebpackBuildSuccess: Resolving with Webpack data');
        resolve(stats);
        return;
    }
    // for all others, reject with an ignorable error
    logger_1.Logger.debug('handleWebpackBuildSuccess: Rejecting with ignorable error');
    reject(new logger_1.IgnorableError());
}
function startWebpackWatch(context, config) {
    logger_1.Logger.debug('Starting Webpack watch');
    var compiler = webpackApi(config);
    context.webpackWatch = compiler.watch({}, function (err, stats) {
        if (err) {
            eventEmitter.emit(INCREMENTAL_BUILD_FAILED, err);
        }
        else {
            eventEmitter.emit(INCREMENTAL_BUILD_SUCCESS, stats);
        }
    });
}
function getWebpackConfig(context, configFile) {
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    var webpackConfig = config_1.fillConfigDefaults(configFile, taskInfo.defaultConfigFile);
    webpackConfig.entry = config_1.replacePathVars(context, webpackConfig.entry);
    webpackConfig.output.path = config_1.replacePathVars(context, webpackConfig.output.path);
    return webpackConfig;
}
exports.getWebpackConfig = getWebpackConfig;
function getOutputDest(context, webpackConfig) {
    return path_1.join(webpackConfig.output.path, webpackConfig.output.filename);
}
exports.getOutputDest = getOutputDest;
function writeFilesToDisk(files) {
    var promises = [];
    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
        var file = files_1[_i];
        promises.push(writeIndividualFile(file));
    }
    return Promise.all(promises);
}
function writeIndividualFile(file) {
    return ensureDirectoriesExist(file.path)
        .then(function () {
        return helpers_1.writeFileAsync(file.path, file.content);
    });
}
function transformPath(originalPath, context) {
    return originalPath.replace(context.srcDir, context.tmpDir);
}
function ensureDirectoriesExist(path) {
    return new Promise(function (resolve, reject) {
        var directoryName = path_1.dirname(path);
        fs_extra_1.mkdirs(directoryName, function (err) {
            if (err) {
                reject(new logger_1.BuildError(err));
            }
            else {
                resolve();
            }
        });
    });
}
function typescriptFilesChanged(tsFiles) {
    var files = [];
    for (var filePath in tsFiles) {
        var sourceAndMapFileArray = typescriptFileChanged(filePath, tsFiles);
        for (var _i = 0, sourceAndMapFileArray_1 = sourceAndMapFileArray; _i < sourceAndMapFileArray_1.length; _i++) {
            var file = sourceAndMapFileArray_1[_i];
            files.push(file);
        }
    }
    return files;
}
function typescriptFileChanged(fileChangedPath, tsFiles) {
    var fileName = path_1.basename(fileChangedPath, '.ts');
    var jsFilePath = path_1.join(path_1.dirname(fileChangedPath), fileName + '.js');
    var sourceFile = { path: jsFilePath, content: tsFiles[fileChangedPath].output };
    var mapFile = { path: jsFilePath + '.map', content: tsFiles[fileChangedPath].map };
    return [sourceFile, mapFile];
}
function otherFileChanged(fileChangedPath) {
    return helpers_1.readFileAsync(fileChangedPath).then(function (content) {
        return { path: fileChangedPath, content: content };
    });
}
var taskInfo = {
    fullArgConfig: '--webpack',
    shortArgConfig: '-w',
    envConfig: 'ionic_webpack',
    defaultConfigFile: 'webpack.config'
};
