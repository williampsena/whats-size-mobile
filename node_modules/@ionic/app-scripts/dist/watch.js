"use strict";
var build_1 = require('./build');
var logger_1 = require('./util/logger');
var config_1 = require('./util/config');
var path_1 = require('path');
var chalk = require('chalk');
var chokidar = require('chokidar');
// https://github.com/paulmillr/chokidar
function watch(context, configFile) {
    context = config_1.generateContext(context);
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    // force watch options
    context.isProd = false;
    context.isWatch = true;
    context.fullBuildCompleted = false;
    var logger = new logger_1.Logger('watch');
    function buildDone() {
        return startWatchers(context, configFile).then(function () {
            logger.ready(chalk.green);
        });
    }
    return build_1.build(context)
        .then(buildDone, buildDone)
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.watch = watch;
function startWatchers(context, configFile) {
    var watchConfig = config_1.fillConfigDefaults(configFile, taskInfo.defaultConfigFile);
    var promises = watchConfig
        .watchers
        .map(function (w, i) { return startWatcher(i, w, context, watchConfig); });
    return Promise.all(promises);
}
function startWatcher(index, watcher, context, watchConfig) {
    return new Promise(function (resolve, reject) {
        prepareWatcher(context, watcher);
        if (!watcher.paths) {
            logger_1.Logger.error("watcher config, index " + index + ": missing \"paths\"");
            resolve();
            return;
        }
        if (!watcher.callback) {
            logger_1.Logger.error("watcher config, index " + index + ": missing \"callback\"");
            resolve();
            return;
        }
        var chokidarWatcher = chokidar.watch(watcher.paths, watcher.options);
        var eventName = 'all';
        if (watcher.eventName) {
            eventName = watcher.eventName;
        }
        chokidarWatcher.on(eventName, function (event, filePath) {
            // if you're listening for a specific event vs 'all',
            // the event is not included and the first param is the filePath
            // go ahead and adjust it if filePath is null so it's uniform
            if (!filePath) {
                filePath = event;
                event = watcher.eventName;
            }
            config_1.setIonicEnvironment(context.isProd);
            filePath = path_1.join(context.rootDir, filePath);
            context.isUpdate = true;
            context.fileChanged = filePath;
            logger_1.Logger.debug("watch callback start, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + filePath);
            function taskDone() {
                // TODO - why is this the way it is?
                console.log('');
                logger_1.Logger.info(chalk.green.bold('watch ready'));
                console.log('');
            }
            var callbackToExecute = function (event, filePath, context, watcher) {
                if (!context.fullBuildCompleted) {
                    return build_1.fullBuildUpdate(event, filePath, context);
                }
                return watcher.callback(event, filePath, context);
            };
            callbackToExecute(event, filePath, context, watcher)
                .then(function () {
                logger_1.Logger.debug("watch callback complete, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + filePath);
                watchCount++;
                taskDone();
            })
                .catch(function (err) {
                logger_1.Logger.debug("watch callback error, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + filePath);
                logger_1.Logger.debug("" + err);
                watchCount++;
                if (!(err instanceof logger_1.IgnorableError)) {
                    taskDone();
                }
            });
        });
        chokidarWatcher.on('ready', function () {
            logger_1.Logger.debug("watcher ready: " + watcher.options.cwd + watcher.paths);
            resolve();
        });
        chokidarWatcher.on('error', function (err) {
            reject(new logger_1.BuildError("watcher error: " + watcher.options.cwd + watcher.paths + ": " + err));
        });
    });
}
function prepareWatcher(context, watcher) {
    watcher.options = watcher.options || {};
    if (!watcher.options.cwd) {
        watcher.options.cwd = context.rootDir;
    }
    if (typeof watcher.options.ignoreInitial !== 'boolean') {
        watcher.options.ignoreInitial = true;
    }
    if (typeof watcher.options.ignored === 'string') {
        watcher.options.ignored = path_1.normalize(config_1.replacePathVars(context, watcher.options.ignored));
    }
    if (typeof watcher.paths === 'string') {
        watcher.paths = path_1.normalize(config_1.replacePathVars(context, watcher.paths));
    }
    else if (Array.isArray(watcher.paths)) {
        watcher.paths = watcher.paths.map(function (p) { return path_1.normalize(config_1.replacePathVars(context, p)); });
    }
}
exports.prepareWatcher = prepareWatcher;
var taskInfo = {
    fullArgConfig: '--watch',
    shortArgConfig: '-w',
    envConfig: 'ionic_watch',
    defaultConfigFile: 'watch.config'
};
var watchCount = 0;
